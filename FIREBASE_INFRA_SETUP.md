# DiscoveryLens Firebase & GCP Infrastructure Setup

This guide summarizes the end-to-end setup for enabling Firebase + Google Cloud services used by DiscoveryLens. It assumes you have the Firebase CLI installed and authenticated (`firebase login`).

## 1. Initialize Firebase in the repo

1. From the project root (`casebuddy-discovery-lens`), run `firebase init`.
2. Select the existing project **`casebuddy-discoverylens`**.
3. Enable:
   - **Firestore** (production mode recommended) – choose a region close to your users, e.g., `us-east4`.
   - **Functions** (TypeScript) – create the `functions/` directory and install dependencies when prompted.
   - **Hosting** – if you plan to host the Next.js app on Firebase Hosting with rewrites to Cloud Run/Vercel, configure as needed.
   - **Storage** – accept the default bucket.
   - **Emulators** – optional, but recommended for local testing.

## 2. Authentication providers

1. In the Firebase Console, open **Authentication → Get started**.
2. Enable **Email/Password** (for OTP/email-link flows) and **Google** providers.
3. Keep all secret keys (e.g., email service API keys) in server-side config: use `firebase functions:config:set` for Cloud Functions or environment variables; never ship secrets to the client.

## 3. Firestore schema & security rules

Create a `firestore.rules` file (if one was not generated) with owner and share enforcement. Deploy with `firebase deploy --only firestore:rules`.

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /discoveryFiles/{fileId} {
      allow read: if request.auth != null
        && (resource.data.ownerId == request.auth.uid
        || resource.data.authorizedUserIds.hasAny([request.auth.uid]));
      allow write: if request.auth != null && resource.data.ownerId == request.auth.uid;
    }
  }
}
```

- Keep metadata (owner, `authorizedUserIds`, summaries, Bates numbers, etc.) in Firestore documents.
- Enforce server-side checks in Cloud Functions before mutating sensitive fields like `authorizedUserIds`.

## 4. Cloud Storage bucket rules

Create or update `storage.rules`, then deploy with `firebase deploy --only storage`.

```
rules_version = '2';
service firebase.storage {
  match /b/{bucket}/o {
    match /discoveryFiles/{ownerId}/{fileId} {
      allow read, write: if request.auth != null && request.auth.uid == ownerId;
    }
  }
}
```

- For shared access, prefer signed URLs generated by a callable HTTPS function that validates Firestore permissions server-side.

## 5. Cloud Functions (TypeScript)

Create functions inside `functions/src/`:

- **onFileUploadTrigger (Storage trigger):**
  - Trigger: `onFinalize` for uploads to `/uploads/{userId}/{fileName}` (adjust as needed).
  - Steps: detect file type → call Document AI for documents → if video/audio, extract/route audio via Cloud Run → send audio to Speech-to-Text → summarize with Vertex AI → generate Bates numbers → write metadata to Firestore → index to Algolia.
- **onShareFile (callable):**
  - Validates caller auth.
  - Updates `authorizedUserIds` on the matching Firestore doc.
  - Returns minimal success/failure payloads.

### Required service APIs
Enable these APIs in Google Cloud Console for `casebuddy-discoverylens`:

- Cloud Vision API (if used by Document AI)
- Document AI API
- Cloud Speech-to-Text API
- Vertex AI API
- Cloud Build API (for Cloud Run deployments)
- Cloud Run API

### Function configuration & secrets

Store secrets with `firebase functions:config:set` (Algolia keys, email provider keys, etc.). Access them via `functions.config()`; never hard-code keys or expose them to the client.

### Dependencies to install in `functions/`

- `@google-cloud/documentai`
- `@google-cloud/speech`
- `@google-cloud/aiplatform`
- `algoliasearch`
- Any transport libs for calling your Cloud Run audio-extraction service

Deploy functions with `firebase deploy --only functions` once implemented.

## 6. Cloud Run for FFmpeg/audio extraction

1. Build a container (Node.js/Express or Python/Flask) with FFmpeg installed.
2. Accept a request with the Cloud Storage path, extract audio, and write back to Storage.
3. Push the image to Artifact Registry or Container Registry.
4. Deploy to Cloud Run and restrict ingress to authenticated invokers (call from Cloud Functions with a service account).
5. Optionally add IAM to limit callers to your Functions service account.

## 7. Algolia search integration

1. Create an Algolia app; obtain **Application ID** and **Admin API Key**.
2. Store credentials securely: `firebase functions:config:set algolia.app_id="APP_ID" algolia.admin_key="ADMIN_KEY"`.
3. In `onFileUploadTrigger`, send processed metadata/text to Algolia for indexing.
4. In the web app, use the search-only key from server-rendered config or an API route; never expose the admin key client-side.

## 8. Deployment & local testing tips

- Use Firebase Emulators for Firestore, Functions, and Storage during development. Configure `firebase.json` to point the app to emulator ports when running locally.
- Keep regional choices consistent (e.g., `us-east4`) for reduced latency between Functions, Firestore, Storage, and Cloud Run.
- Add CI checks to lint and test Functions before deploy (e.g., `npm test --workspace functions`).
- Review IAM roles regularly; least privilege for service accounts (Functions → Storage Object Admin scoped to bucket, Firestore user, Cloud Run Invoker for the audio service, etc.).

## 9. Next steps for DiscoveryLens

- Wire the upload UI to place files under the expected Storage prefix used by `onFileUploadTrigger`.
- Add UI flows for sharing that call the `onShareFile` callable function.
- Propagate Bates numbers and summaries into the UI from Firestore documents for downstream workflows.
- Add monitoring/alerting (Cloud Monitoring) for Functions and Cloud Run errors.

